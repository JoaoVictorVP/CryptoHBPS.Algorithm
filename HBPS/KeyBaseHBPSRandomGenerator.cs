using System.Diagnostics.CodeAnalysis;

namespace CryptoHBPS;

/// <summary>
/// A key-based random generator for <see cref="HBPS"/> to use
/// </summary>
public class KeyBaseHBPSRandomGenerator : IHBPSRandomGenerator
{
    /// <summary>
    /// The current master key
    /// </summary>
    public readonly byte[] Key;
    /// <summary>
    /// Current round of this generator
    /// </summary>
    public int Rounds;
    Random[] random;

    int maskSize;
    
    int size;

    public void Fill(Span<byte> bytes)
    {
        // Make a new mask of specified size that will be used to, literally, mask the input bytes
        Span<byte> mask = stackalloc byte[maskSize];
        for (int i = 0; i < maskSize; i++)
            mask[i] = (byte)random[i % size].Next(byte.MinValue, byte.MaxValue);

        // Make's a random generator to give some more "entropy" into the bytes individual output than maskSize can provide by itself
        var coherence = new Random(mask[0] * mask[1] * mask[2] * mask[3]);

        int count = bytes.Length;
        for (int i = 0; i < count; i++)
            bytes[i] = (byte)(mask[i % maskSize] * coherence.Next());
    }

    void init()
    {
        random = new Random[size];
        for (int i = 0; i < size; i++)
            random[i] = new Random(Key[i] * i);

        maskSize = size * 3;

        // Advances the key generator by specified rounds in order to make him respect the current generational order when reconstructing object
        for (int round = 0; round < Rounds; round++)
            for (int i = 0; i < maskSize; i++)
                random[i % size].Next();
    }

    /// <summary>
    /// Create's an instance of Key-Based HBPS Random Generator
    /// </summary>
    /// <param name="key">The master key that will feed this generator deterministically</param>
    /// <param name="rounds">The ammount of rounds already generated by this random generator</param>
    public KeyBaseHBPSRandomGenerator([NotNull] byte[] key, int rounds = 0)
    {
        Key = key;
        Rounds = rounds;
        size = key.Length;

        init();
    }
}