// Namespace
using CryptoHBPS;
using System.Text;

// How to create properly a HBPS instance

// the example here will use a full random one, but you can efectively use key-based if needed

// For random generation of values inside HBPS
var randomGenerator = new HBPSRandomGenerator();

// For hashing inside HBPS (extensible)
var hashGenerator = new HMACSHA256Generator();

var hbps = new HBPS(randomGenerator, hashGenerator);

// To generate a new private key / public key pair (using desconstruction)
var (key, pkey) = hbps.Get();

// To verify if some public key was generated by private key (one time function)
bool validPublicKey = hbps.Validate(key, pkey);

// To sign an arbitrary message with the key pair
var message = Encoding.Unicode.GetBytes("I am sending to <Bob> [3000 BTC]");

byte[] signature = new byte[hashGenerator.Size * 2];
hbps.Sign(key, pkey, message, signature);

// To verify if some signature was signed by public key
bool signedWithPublicKey = hbps.IsSignedWithPublicKey(pkey, message, signature);

// To verify if the signature was signed by both public and private key (one time function)
bool fullySigned = hbps.IsSignedWithPrivateKey(key, pkey, message, signature);

// Running
Console.WriteLine("Private Key: " + key);
Console.WriteLine("Public Key: " + pkey);
Console.WriteLine("Is public key valid? " + validPublicKey);

Console.WriteLine();

Console.WriteLine("Message to be signed: " + Encoding.Unicode.GetString(message) + '\n');

Console.WriteLine();

Console.WriteLine("Signature: " + Convert.ToHexString(signature));
Console.WriteLine("Was Signed by public key? " + signedWithPublicKey);
Console.WriteLine("Is this signature fully signed? " + fullySigned);

Console.ReadKey(true);